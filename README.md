<h3>Домашнее задание 1. Обход файлов</h3><ol><li>
            Разработайте класс <tt>Walk</tt>, осуществляющий подсчет хеш-сумм файлов.
            <ol><li>
                    Формат запуска
                    <pre>java Walk &lt;входной файл&gt; &lt;выходной файл&gt;</pre></li><li>
                    Входной файл содержит список файлов, которые требуется обойти.
                </li><li>
                    Выходной файл должен содержать по одной строке для каждого
                    файла. Формат строки:
                    <pre>&lt;шестнадцатеричная хеш-сумма&gt; &lt;путь к файлу&gt;</pre></li><li>
                    Для подсчета хеш-суммы используйте алгоритм
                    <a href="https://ru.wikipedia.org/wiki/FNV">FNV</a>.
                </li><li>
                    Если при чтении файла возникают ошибки, укажите в качестве
                    его хеш-суммы <tt>00000000</tt>.
                </li><li>
                    Кодировка входного и выходного файлов &mdash; UTF-8.
                </li><li>
                    Если родительская директория выходного файла
                    не существует, то соответствующий путь надо создать.
                </li><li>
                    Размеры файлов могут превышать размер оперативной памяти.
                </li><li><p>Пример</p><p>Входной файл</p><pre>
                        java/info/kgeorgiy/java/advanced/walk/samples/1
                        java/info/kgeorgiy/java/advanced/walk/samples/12
                        java/info/kgeorgiy/java/advanced/walk/samples/123
                        java/info/kgeorgiy/java/advanced/walk/samples/1234
                        java/info/kgeorgiy/java/advanced/walk/samples/1
                        java/info/kgeorgiy/java/advanced/walk/samples/binary
                        java/info/kgeorgiy/java/advanced/walk/samples/no-such-file
                    </pre><p>Выходной файл</p><pre>
                        050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                        2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
                        72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
                        81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
                        050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                        8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                        00000000 java/info/kgeorgiy/java/advanced/walk/samples/no-such-file
                    </pre></li></ol></li><li>
            Усложненная версия:
            <ol><li>
                    Разработайте класс <tt>RecursiveWalk</tt>,
                    осуществляющий подсчет хеш-сумм файлов в
                    директориях
                </li><li>
                    Входной файл содержит список файлов и директорий,
                    которые требуется обойти. Обход директорий осуществляется
                    рекурсивно.
                </li><li><p>Пример</p><p>Входной файл</p><pre>
                        java/info/kgeorgiy/java/advanced/walk/samples/binary
                        java/info/kgeorgiy/java/advanced/walk/samples
                    </pre><p>Выходной файл</p><pre>
                        8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                        050c5d2e java/info/kgeorgiy/java/advanced/walk/samples/1
                        2076af58 java/info/kgeorgiy/java/advanced/walk/samples/12
                        72d607bb java/info/kgeorgiy/java/advanced/walk/samples/123
                        81ee2b55 java/info/kgeorgiy/java/advanced/walk/samples/1234
                        8e8881c5 java/info/kgeorgiy/java/advanced/walk/samples/binary
                    </pre></li></ol></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Дизайн и обработку исключений, диагностику ошибок.
                </li><li>
                    Программа должна корректно завершаться даже в случае ошибки.
                </li><li>
                    Корректная работа с вводом-выводом.
                </li><li>
                    Отсутствие утечки ресурсов.
                </li></ul></li><li>
            Требования к оформлению задания.
            <ul><li>
                    Проверяется исходный код задания.
                </li><li>
                    Весь код должен находиться в пакете
                    <tt>ru.ifmo.rain.фамилия.walk</tt>.
                </li></ul></li></ol><p><a href="https://www.kgeorgiy.info/git/geo/java-advanced-2020">Тесты к домашним заданиям</a></p><h3 id="homework-2">Домашнее задание 2. Множество на массиве</h3><ol><li>
            Разработайте класс <tt>ArraySet</tt>,
            реализующие неизменяемое упорядоченное множество.
            <ul><li>
                    Класс <tt>ArraySet</tt> должен реализовывать
                    интерфейс <tt>SortedSet</tt> (упрощенная версия)
                    или <tt>NavigableSet</tt> (усложненная версия).
                </li><li>
                    Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Применение стандартных коллекций.
                </li><li>
                    Избавление от повторяющегося кода.
                </li></ul></li></ol><h3 id="homework-3">Домашнее задание 3. Студенты</h3><ol><li>
            Разработайте класс <tt>StudentDB</tt>,
            осуществляющий поиск по базе данных студентов.
            <ul><li>
                    Класс <tt>StudentDB</tt> должен реализовывать
                    интерфейс <tt>StudentQuery</tt> (простая версия)
                    или <tt>StudentGroupQuery</tt> (сложная версия).
                </li><li>
                    Каждый метод должен состоять из ровно одного оператора.
                    При этом длинные операторы надо разбивать на несколько строк.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Применение лямбда-выражений и потоков.
                </li><li>
                    Избавление от повторяющегося кода.
                </li></ul></li></ol><h3 id="homework-4">Домашнее задание 4. Implementor</h3><ol><li>
            Реализуйте класс <tt>Implementor</tt>, который будет генерировать
            реализации классов и интерфейсов.
            <ul><li>
                    Аргумент командной строки: полное имя класса/интерфейса, для
                    которого требуется сгенерировать реализацию.
                </li><li>
                    В результате работы должен быть сгенерирован java-код класса с суффиксом
                    <tt>Impl</tt>, расширяющий (реализующий) указанный класс (интерфейс).
                </li><li>
                    Сгенерированный класс должен компилироваться без ошибок.
                </li><li>
                    Сгенерированный класс не должен быть абстрактным.
                </li><li>
                    Методы сгенерированного класса должны игнорировать свои аргументы и
                    возвращать значения по умолчанию.
                </li></ul></li><li>
            В задании выделяются три уровня сложности:
            <ul><li><em>Простой</em> &mdash; <tt>Implementor</tt> должен уметь реализовывать
                    только интерфейсы (но не классы). Поддержка generics не требуется.
                </li><li><em>Сложный</em> &mdash; <tt>Implementor</tt> должен уметь реализовывать
                    и классы и интерфейсы. Поддержка generics не требуется.
                </li><li><em>Бонусный</em> &mdash; <tt>Implementor</tt> должен уметь реализовывать
                    generic-классы и интерфейсы. Сгенерированный код должен иметь
                    корректные параметры типов и не порождать <tt>UncheckedWarning</tt>.
                </li></ul></li></ol><h3 id="homework-5">Домашнее задание 5. Jar Implementor</h3><ol><li>
            Создайте <tt>.jar</tt>-файл, содержащий скомпилированный
            <tt>Implementor</tt> и сопутствующие классы.
            <ul><li>
                    Созданный <tt>.jar</tt>-файл должен запускаться командой
                    <tt>java -jar</tt>.
                </li><li>
                    Запускаемый <tt>.jar</tt>-файл должен принимать те же аргументы командной
                    строки, что и класс <tt>Implementor</tt>.
                </li></ul></li><li>
            Модифицируйте <tt>Implemetor</tt> так, что бы
            при запуске с аргументами <tt>-jar имя-класса файл.jar</tt>
            он генерировал <tt>.jar</tt>-файл с реализацией
            соответствующего класса (интерфейса).
        </li><li>
            Для проверки, кроме исходного кода так же должны быть предъявлены:
            <ul><li>
                    скрипт для создания запускаемого <tt>.jar</tt>-файла, в том числе,
                    исходный код манифеста;
                </li><li>
                    запускаемый <tt>.jar</tt>-файл.
                </li></ul></li><li>
            Данное домашнее задание сдается только вместе с предыдущим.
            Предыдущее домашнее задание отдельно сдать будет нельзя.
        </li><li><b>Сложная версия</b>. Решение должно быть модуляризовано.
        </li></ol><h3 id="homework-6">Домашнее задание 6. Javadoc</h3><ol><li>
            Документируйте класс <tt>Implementor</tt> и сопутствующие классы с применением
            Javadoc.
            <ul><li>
                    Должны быть документированы все классы и все члены классов, в том числе
                    <tt>private</tt>.
                </li><li>
                    Документация должна генерироваться без предупреждений.
                </li><li>
                    Сгенерированная документация должна содержать корректные ссылки на
                    классы стандартной библиотеки.
                </li></ul></li><li>
            Для проверки, кроме исходного кода так же должны быть предъявлены:
            <ul><li>
                    скрипт для генерации документации;
                </li><li>
                    сгенерированная документация.
                </li></ul></li><li>
            Данное домашнее задание сдается только вместе с предыдущим.
            Предыдущее домашнее задание отдельно сдать будет нельзя.
        </li></ol><h3 id="homework-7">Домашнее задание 7. Итеративный параллелизм</h3><ol><li>
            Реализуйте класс <tt>IterativeParallelism</tt>,
            который будет обрабатывать списки в несколько потоков.
        </li><li>
            В <i>простом</i> варианте должны быть реализованы следующие методы:
            <ul><li><tt>minimum(threads, list, comparator)</tt> &mdash;
                    первый минимум;
                </li><li><tt>maximum(threads, list, comparator)</tt> &mdash;
                    первый максимум;
                </li><li><tt>all(threads, list, predicate)</tt> &mdash;
                    проверка, что все элементы списка удовлетворяют
                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">предикату</a>;
                </li><li><tt>any(threads, list, predicate)</tt> &mdash;
                    проверка, что существует элемент списка, удовлетворяющий
                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">предикату</a>.
                </li></ul></li><li>
            В <i>сложном</i> варианте должны быть дополнительно реализованы следующие методы:
            <ul><li><tt>filter(threads, list, predicate)</tt> &mdash;
                    вернуть список, содержащий элементы удовлетворяющие
                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">предикату</a>;
                </li><li><tt>map(threads, list, function)</tt> &mdash;
                    вернуть список, содержащий результаты применения
                    <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">функции</a>;
                </li><li><tt>join(threads, list)</tt> &mdash;
                    конкатенация строковых представлений
                    элементов списка.
                </li></ul></li><li>
            Во все функции передается параметр <tt>threads</tt> &mdash;
            сколько потоков надо использовать при вычислении.
            Вы можете рассчитывать, что число потоков не велико.
        </li><li>
            Не следует рассчитывать на то, что переданные компараторы,
            предикаты и функции работают быстро.
        </li><li>
            При выполнении задания нельзя использовать
            <i>Concurrency Utilities</i>.
        </li><li>
            Рекомендуется подумать, какое отношение к
            заданию имеют <a href="https://en.wikipedia.org/wiki/Monoid">моноиды</a>.
        </li></ol><h3 id="homework-8">Домашнее задание 8. Параллельный запуск</h3><ol><li>
            Напишите класс <tt>ParallelMapperImpl</tt>, реализующий интерфейс
            <tt>ParallelMapper</tt>.
<pre>
public interface ParallelMapper extends AutoCloseable {
    &lt;T, R&gt; List&lt;R&gt; run(
        Function&lt;? super T, ? extends R&gt; f,
        List&lt;? extends T&gt; args
    ) throws InterruptedException;

    @Override
    void close() throws InterruptedException;
}
</pre><ul><li>
                    Метод <tt>run</tt> должен параллельно вычислять
                    функцию <tt>f</tt> на каждом из указанных аргументов
                    (<tt>args</tt>).
                </li><li>
                    Метод <tt>close</tt> должен останавливать все рабочие потоки.
                </li><li>
                    Конструктор <tt>ParallelMapperImpl(int threads)</tt>
                    создает <tt>threads</tt> рабочих потоков, которые могут
                    быть использованы для распараллеливания.
                </li><li>
                    К одному <tt>ParallelMapperImpl</tt> могут одновременно обращаться
                    несколько клиентов.
                </li><li>
                    Задания на исполнение должны накапливаться в очереди и обрабатываться
                    в порядке поступления.
                </li><li>
                    В реализации не должно быть активных ожиданий.
                </li></ul></li><li>
            Добавьте класс <tt>IterativeParallelism</tt> так,
            чтобы он мог использовать <tt>ParallelMapper</tt>.
            <ul><li>
                    Добавьте конструктор <tt>IterativeParallelism(ParallelMapper)</tt></li><li>
                    Методы класса должны делить работу на <tt>threads</tt>
                    фрагментов и исполнять их при помощи <tt>ParallelMapper</tt>.
                </li><li>
                    Должна быть возможность одновременного запуска и работы
                    нескольких клиентов, использующих один <tt>ParallelMapper</tt>.
                </li><li>
                    При наличии <tt>ParallelMapper</tt> сам
                    <tt>IterativeParallelism</tt> новые потоки создавать не должен.
                </li></ul></li></ol><h3 id="homework-9">Домашнее задание 9. Web Crawler</h3><ol><li>
            Напишите потокобезопасный класс <tt>WebCrawler</tt>, который
            будет рекурсивно обходить сайты.
            <ol><li>
                    Класс <tt>WebCrawler</tt> должен иметь конструктор
                    <pre>
                        public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
                    </pre><ul><li><tt>downloader</tt> позволяет скачивать страницы и
                            извлекать из них ссылки;
                        </li><li><tt>downloaders</tt> &mdash; максимальное число
                            одновременно загружаемых страниц;
                        </li><li><tt>extractors</tt> &mdash; максимальное число страниц,
                            из которых извлекаются ссылки;
                        </li><li><tt>perHost</tt> &mdash; максимальное число страниц,
                            одновременно загружаемых c одного хоста.
                            Для опредения хоста следует использовать
                            метод <tt>getHost</tt> класса
                            <tt>URLUtils</tt> из тестов.
                        </li></ul></li><li>
                    Класс <tt>WebCrawler</tt> должен реализовывать интерфейс
                    <tt>Crawler</tt>
                <pre>
                        public interface Crawler extends AutoCloseable {
                            Result download(String url, int depth);
                            void close();
                        }
                    </pre><ul><li>
                            Метод <tt>download</tt> должен рекурсивно обходить страницы,
                            начиная с указанного URL на указанную глубину и
                            возвращать список загруженных страниц и файлов.
                            Например, если глубина равна 1, то должна быть
                            загружена только указанная страница. Если глубина равна
                            2, то указанная страница и те страницы и файлы, на которые
                            она ссылается и так далее.
                            Этот метод может вызываться параллельно в нескольких потоках.
                        </li><li>
                            Загрузка и обработка страниц (извлечение ссылок)
                            должна выполняться максимально параллельно,
                            с учетом ограничений на число одновременно
                            загружаемых страниц (в том числе с одного хоста)
                            и страниц, с которых загружаются ссылки.
                        </li><li>
                            Для распараллеливания разрешается создать
                            до <tt>downloaders + extractors</tt>
                            вспомогательных потоков.
                        </li><li>
                            Загружать и/или извлекать ссылки из одной
                            и той же страницы в рамках одного обхода
                            (<tt>download</tt>) запрещается.
                        </li><li>
                            Метод <tt>close</tt> должен завершать все
                            вспомогательные потоки.
                        </li></ul></li><li>
                    Для загрузки страниц должен применяться <tt>Downloader</tt>,
                    передаваемый первым аргументом конструктора.
                    <pre>
                        public interface Downloader {
                            public Document download(final String url) throws IOException;
                        }
                    </pre><ul><li>
                            Метод <tt>download</tt> загружает документ по его адресу
                            (<a href="http://tools.ietf.org/html/rfc3986">URL</a>).
                        </li><li>
                            Документ позволяет получить ссылки по загруженной странице:
                <pre>
                    public interface Document {
                        List&lt;String&gt; extractLinks() throws IOException;
                    }
                </pre>
                            Ссылки, возвращаемые документом являются абсолютными
                            и имеют схему <tt>http</tt> или <tt>https</tt>.
                        </li></ul></li><li>
                    Должен быть реализован метод <tt>main</tt>,
                    позволяющий запустить обход из командной строки
                    <ul><li>
                            Командная строка
                <pre>
                    WebCrawler url [depth [downloads [extractors [perHost]]]]
                </pre></li><li>
                            Для загрузки страниц требуется использовать реализацию
                            <tt>CachingDownloader</tt> из тестов.
                        </li></ul></li></ol></li><li>
            Версии задания
            <ol><li><em>Простая</em> &mdash; можно не учитывать ограничения
                    на число одновременных закачек с одного хоста
                    <tt>(perHost &gt;= downloaders)</tt>.
                </li><li><em>Полная</em> &mdash; требуется учитывать все ограничения.
                </li><li><em>Бонусная</em> &mdash; сделать параллельный обод в ширину.
                </li></ol></li></ol><h3 id="homework-10">Домашнее задание 10. HelloUDP</h3><ol><li>
            Реализуйте клиент и сервер, взаимодействующие по UDP.
        </li><li>
            Класс <tt>HelloUDPClient</tt> должен отправлять запросы
            на сервер, принимать результаты и выводить их на консоль.
            <ul><li>
                    Аргументы командной строки:
                    <ol><li>имя или ip-адрес компьютера, на котором запущен сервер;</li><li>номер порта, на который отсылать запросы;</li><li>префикс запросов (строка);</li><li>число параллельных потоков запросов;</li><li>число запросов в каждом потоке.</li></ol></li><li>
                    Запросы должны одновременно отсылаться в указанном числе потоков.
                    Каждый поток должен ожидать обработки своего запроса и выводить
                    сам запрос и результат его обработки на консоль.
                    Если запрос не был обработан, требуется послать его заново.
                </li><li>
                    Запросы должны формироваться по схеме
                    <tt>&lt;префикс запросов&gt;&lt;номер потока&gt;_&lt;номер запроса в потоке&gt;</tt>.
                </li></ul></li><li>
            Класс <tt>HelloUDPServer</tt> должен принимать задания, отсылаемые
            классом <tt>HelloUDPClient</tt> и отвечать на них.
            <ul><li>
                    Аргументы командной строки:
                    <ol><li>номер порта, по которому будут приниматься запросы;</li><li>число рабочих потоков, которые будут обрабатывать запросы.</li></ol></li><li>
                    Ответом на запрос должно быть <tt>Hello, &lt;текст запроса&gt;</tt>.
                </li><li>
                    Если сервер не успевает обрабатывать запросы, прием запросов может
                    быть временно приостановлен.
                </li></ul></li></ol><h3 id="homework-11">Домашнее задание 11. Физические лица</h3><ol><li>
            Добавьте к банковскому приложению возможность работы с физическими
            лицами.
            <ol><li>
                    У физического лица (<code>Person</code>) можно запросить имя, фамилию и номер паспорта.
                </li><li>
                    Локальные физические лица (<code>LocalPerson</code>) должны передаваться при помощи
                    механизма сериализации.
                </li><li>
                    Удалённые физические лица (<code>RemotePerson</code>) должны передаваться при помощи
                    удалённых объектов.
                </li><li>
                    Должна быть возможность поиска физического лица по
                    номеру паспорта, с выбором типа возвращаемого лица.
                </li><li>
                    Должна быть возможность создания записи о физическом лице по его данным.
                </li><li>
                    У физического лица может быть несколько счетов, к которым должен
                    предоставляться доступ.
                </li><li>
                    Счету физического лица с идентификатором <var>subId</var>
                    должен соответствовать банковский счет с <var>id</var>
                    вида <var>passport</var>:<var>subId</var>.
                </li><li>
                    Изменения, производимые со счетом в банке
                    (создание и изменение баланса), должны быть видны всем
                    соответствующим <code>RemotePerson</code>, и только тем
                    <code>LocalPerson</code>, которые были созданы после этого изменения.
                </li><li>
                    Изменения в счетах, производимые через <code>RemotePerson</code>,
                    должны сразу применяться глобально, а производимые
                    через <code>LocalPerson</code> &ndash; только локально
                    для этого конкретного <code>LocalPerson</code>.
                </li></ol></li><li>
            Реализуйте приложение, демонстрирующее работу с физическим лицами.
            <ol><li>
                    Аргументы командной строки: имя, фамилия, номер паспорта физического
                    лица, номер счета, изменение суммы счета.
                </li><li>
                    Если информация об указанном физическом лице отсутствует, то оно должно
                    быть добавлено. В противном случае &ndash; должны быть проверены его данные.
                </li><li>
                    Если у физического лица отсутствует счет с указанным номером, то
                    он создается с нулевым балансом.
                </li><li>
                    После обновления суммы счета новый баланс должен выводиться на консоль.
                </li></ol></li><li>
            Напишите тесты, проверяющее вышеуказанное поведение как банка, так и приложения.
            <ul><li>
                    Для реализации тестов рекомендуется использовать
                    <a href="https://junit.org/junit5/">JUnit</a>
                    (<a href="https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/">Tutorial</a>).
                    Множество примеров использования можно найти в тестах.
                </li><li>
                    Если вы знакомы с другим тестовым фреймворком
                    (например, <a href="https://testng.org/">TestNG</a>),
                    то можете использовать его.
                </li><li>
                    Использовать самописные фреймворки и тесты запускаемые
                    через <code>main</code> нельзя.
                </li></ul></li><li>
            Весь код должен находиться в пакете
            <code>ru.ifmo.rain.<em>фамилия</em>.bank</code> и его подпакетах
        </li><li><b>Сложный вариант</b><ol><li>
                    Тесты не должны рассчитывать на наличие запущенного
                    RMI Registry.
                </li><li>
                    Создайте класс <code>BankTests</code>, запускающий тесты.
                </li><li>
                    Создайте скрипт, запускающий <code>BankTests</code>
                    и возвращающий код (статус) <code>0</code>
                    в случае успеха и <code>1</code> в случае неудачи.
                </li><li>
                    Создайте скрипт, запускающий тесты с использованием
                    стандартного подхода для вашего тестового фреймворка.
                    Код возврата должен быть как в предыдущем пункте.
                </li></ol></li></ol><h3 id="homework-12">Домашнее задание 12. HelloNonblockingUDP</h3><ol><li>
            Реализуйте клиент и сервер, взаимодействующие по UDP,
            используя только неблокирующий ввод-вывод.
        </li><li>
            Класс <code>HelloUDPNonblockingClient</code> должен
            иметь функциональность аналогичную <code>HelloUDPClient</code>,
            но без создания новых потоков.
        </li><li>
            Класс <code>HelloUDPNonblockingServer</code> должен
            иметь функциональность аналогичную <code>HelloUDPServer</code>,
            но все операции с сокетом должны производиться в одном потоке.
        </li><li>
            В реализации не должно быть активных ожиданий,
            в том числе через <code>Selector</code>.
        </li><li>
            Обратите внимание на выделение общего кода старой и новой реализации.
        </li><li><em>Бонусный вариант</em>.
            Клиент и сервер могут перед началом работы выделить
            O(число потоков) памяти.
            Выделять дополнительную память во время работы запрещено.
